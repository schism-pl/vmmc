diff --git a/vmmc/Cargo.toml b/vmmc/Cargo.toml
index 4ac6a62..5563312 100644
--- a/vmmc/Cargo.toml
+++ b/vmmc/Cargo.toml
@@ -13,5 +13,5 @@ path = "src/bin/vmmc_run.rs"
 anyhow = "1.0.75"
 env_logger = "0.10.0"
 log = "0.4.20"
-rand = "0.8.5"
+rand = { version = "0.8.5", features = ["small_rng"] }
 rand_distr = "0.4.3"
diff --git a/vmmc/src/bin/vmmc_run.rs b/vmmc/src/bin/vmmc_run.rs
index f35edd7..d1e95a1 100644
--- a/vmmc/src/bin/vmmc_run.rs
+++ b/vmmc/src/bin/vmmc_run.rs
@@ -1,3 +1,5 @@
+use rand::rngs::SmallRng;
+use rand::{Rng, SeedableRng};
 use std::f64::consts::PI;
 use vmmc::{
     io::{read_xyz_snapshot, write_tcl, XYZReader, XYZWriter},
@@ -11,13 +13,13 @@ use vmmc::{
 // Try to formalize correctness conditions of box / particles?
 
 // TODO: probably need to check for overlapping and particles and do some other checks
-fn randomized_particles(simbox: &SimBox, n: usize) -> Vec<Particle> {
+fn randomized_particles(simbox: &SimBox, n: usize, rng: &mut SmallRng) -> Vec<Particle> {
     let mut particles = Vec::new();
-    let mut rng = rand::thread_rng();
+
     for idx in 0..n {
-        let pos = simbox.random_pos(&mut rng);
-        let or = Orientation::unit_vector(&mut rng);
-        let particle = Particle::new(idx, pos, or);
+        let pos = simbox.random_pos(rng);
+        let or = Orientation::unit_vector(rng);
+        let particle = Particle::new(idx as u16, pos, or);
         particles.push(particle);
     }
     particles
@@ -37,7 +39,7 @@ fn particles_from_xyz(path: &str) -> Vec<Particle> {
         // let or = Orientation::unit_vector(&mut rng);
         let pos = positions[idx];
         let or = orientations[idx];
-        let particle = Particle::new(idx, pos, or);
+        let particle = Particle::new(idx as u16, pos, or);
         particles.push(particle);
     }
     particles
@@ -104,12 +106,15 @@ fn main() {
     println!("Cell dimensions: {:?}", cell_dimensions);
     println!("Initial average energy: {:?}", vmmc.get_average_energy());
 
+    //let mut rng = rand::thread_rng();
+    let mut rng = SmallRng::seed_from_u64(1337);
+
     for idx in 0..10 {
-        vmmc.step_n(1000 * num_particles);
+        vmmc.step_n(1000 * num_particles, &mut rng);
         // writer.write_xyz_frame(&vmmc);
         println!(
             "Step {:?}: average particle energy = {:?}",
-            idx * 1000 * num_particles,
+            (idx + 1) * 1000 * num_particles,
             vmmc.get_average_energy()
         );
     }
diff --git a/vmmc/src/particle.rs b/vmmc/src/particle.rs
index fadce66..d501141 100644
--- a/vmmc/src/particle.rs
+++ b/vmmc/src/particle.rs
@@ -1,8 +1,8 @@
-use rand::rngs::ThreadRng;
+use rand::rngs::SmallRng;
 
 use crate::position::{Orientation, Position};
 
-pub type ParticleId = usize;
+pub type ParticleId = u16;
 
 pub trait IsParticle {
     fn pos(&self) -> Position;
@@ -47,7 +47,7 @@ impl Particle {
         self.or = self.or.rotated_by(other, theta)
     }
 
-    pub fn random(rng: &mut ThreadRng, id: ParticleId) -> Self {
+    pub fn random(rng: &mut SmallRng, id: ParticleId) -> Self {
         Particle::new(id, Position::random(rng), Orientation::random(rng))
     }
 }
diff --git a/vmmc/src/patchy_discs.rs b/vmmc/src/patchy_discs.rs
index 68e88bd..feee077 100644
--- a/vmmc/src/patchy_discs.rs
+++ b/vmmc/src/patchy_discs.rs
@@ -74,7 +74,7 @@ impl PatchyDiscsPotential {
         let or1 = particle1.or();
 
         // we could make this norm_sqd if that made things faster?
-        let dist = simbox.sep_in_box(p0, p1).norm();
+        let dist = simbox.sep_in_box(p0, p1).norm_sqd();
 
         if dist < 1.0 {
             return f64::INFINITY;
@@ -91,7 +91,7 @@ impl PatchyDiscsPotential {
                 let sqd_dist = simbox.sep_in_box(new_p0, new_p1).norm_sqd();
 
                 if sqd_dist < self.params.sqd_cutoff_distance {
-                    energy += self.params.interaction_energy;
+                    energy = self.params.interaction_energy;
                 }
             }
         }
@@ -108,7 +108,7 @@ impl PatchyDiscsPotential {
         log::debug!("Determining interactions for p{:?}", p.id());
         let mut interactions = Vec::new();
         for neighbor_id in simbox.get_neighbors(p) {
-            let neighbor = &particles[neighbor_id];
+            let neighbor = &particles[neighbor_id as usize];
             if neighbor == p {
                 continue;
             }
@@ -126,7 +126,7 @@ impl PatchyDiscsPotential {
                     println!("{:?} {:?}", p, interactions);
                     println!("--- {:?}", neighbor);
                     for &interacting_p_id in interactions.iter() {
-                        println!("--- {:?}", &particles[interacting_p_id]);
+                        println!("--- {:?}", &particles[interacting_p_id as usize]);
                     }
                 }
                 assert_ne!(interactions.len(), self.params.max_interactions);
diff --git a/vmmc/src/position.rs b/vmmc/src/position.rs
index 6e893c4..75df1d0 100644
--- a/vmmc/src/position.rs
+++ b/vmmc/src/position.rs
@@ -3,7 +3,7 @@ use std::{
     ops::{Add, AddAssign, Div, Sub, SubAssign},
 };
 
-use rand::rngs::ThreadRng;
+use rand::rngs::SmallRng;
 use rand_distr::{Distribution, Normal};
 
 use crate::params::DIMENSION;
@@ -56,7 +56,7 @@ impl DimVec {
         r
     }
 
-    pub fn random(rng: &mut ThreadRng) -> Self {
+    pub fn random(rng: &mut SmallRng) -> Self {
         let normal = Normal::new(0.0, 1.0).unwrap();
         let mut r = Position::zeroes();
         for idx in 0..DIMENSION {
@@ -66,7 +66,7 @@ impl DimVec {
     }
 
     // picks a random position then does a scalar div by maginitude
-    pub fn unit_vector(rng: &mut ThreadRng) -> Self {
+    pub fn unit_vector(rng: &mut SmallRng) -> Self {
         let rand_pos = Position::random(rng);
         let norm = rand_pos.norm();
         rand_pos.scalar_div(norm)
diff --git a/vmmc/src/simbox.rs b/vmmc/src/simbox.rs
index 0bcd7e4..906bf57 100644
--- a/vmmc/src/simbox.rs
+++ b/vmmc/src/simbox.rs
@@ -1,4 +1,4 @@
-use rand::{rngs::ThreadRng, Rng};
+use rand::{rngs::SmallRng, Rng};
 
 use crate::params::MAX_PARTICLES_PER_CELL;
 use crate::{
@@ -288,7 +288,7 @@ impl SimBox {
         // Position::new([x, y])
     }
 
-    pub fn random_pos(&self, rng: &mut ThreadRng) -> Position {
+    pub fn random_pos(&self, rng: &mut SmallRng) -> Position {
         let x = rng.gen_range(self.min_x()..self.max_x());
         let y = rng.gen_range(self.min_y()..self.max_y());
         Position::new([x, y])
diff --git a/vmmc/src/vmmc.rs b/vmmc/src/vmmc.rs
index dd1e503..c840b58 100644
--- a/vmmc/src/vmmc.rs
+++ b/vmmc/src/vmmc.rs
@@ -5,7 +5,7 @@ use crate::simbox::SimBox;
 use crate::stats::RunStats;
 use crate::{params::DIMENSION, position::DimVec};
 use anyhow::{anyhow, Result};
-use rand::rngs::ThreadRng;
+use rand::rngs::SmallRng;
 use rand::Rng;
 use rand_distr::num_traits::Zero;
 use std::collections::{HashSet, VecDeque};
@@ -144,6 +144,10 @@ impl Vmmc {
         &self.potential
     }
 
+    pub fn particle(&self, p_id: ParticleId) -> &Particle {
+        &self.particles[p_id as usize]
+    }
+
     // get energy
     pub fn get_particle_energy(&self, p: &Particle) -> f64 {
         let mut energy = 0.0;
@@ -151,7 +155,7 @@ impl Vmmc {
             .potential
             .determine_interactions(&self.simbox, &self.particles, p);
         for &neighbor_id in interactions.iter() {
-            let neighbor = &self.particles[neighbor_id];
+            let neighbor = self.particle(neighbor_id);
             energy += self
                 .potential
                 .compute_pair_energy(self.simbox(), p, neighbor);
@@ -179,7 +183,7 @@ impl Vmmc {
                 self.simbox.sep_in_box(vp.orig_pos(), center_of_mass)
             } else {
                 self.simbox
-                    .sep_in_box(vp.orig_pos(), self.particles[mov.seed_id].pos())
+                    .sep_in_box(vp.orig_pos(), self.particle(mov.seed_id).pos())
             };
 
             stokes_radius += delta.cross_prod_magnitude_sqd(mov.vec);
@@ -228,7 +232,7 @@ impl Vmmc {
         VParticle::new(particle.pos(), particle.or(), final_p, final_or)
     }
 
-    fn choose_random_move(&self, rng: &mut ThreadRng) -> ProposedMove {
+    fn choose_random_move(&self, rng: &mut SmallRng) -> ProposedMove {
         // 1. Choose a particle that will lead the move
         let seed_id = self.choose_seed(rng);
         // 2. Choose a direction (unit vector) for the move
@@ -253,8 +257,8 @@ impl Vmmc {
 
     // Note: each particle gets to attempt to link to every neighbor, even if neighbor
     // has tried to be recruited before
-    fn recruit_cluster(&self, rng: &mut ThreadRng, mov: &ProposedMove) -> Result<VirtualMoves> {
-        let seed: &Particle = &self.particles[mov.seed_id];
+    fn recruit_cluster(&self, rng: &mut SmallRng, mov: &ProposedMove) -> Result<VirtualMoves> {
+        let seed = self.particle(mov.seed_id);
         // particles in the cluster who still need to make their linking pass
         let mut worklist = VecDeque::from([mov.seed_id]);
         // particles who have made their linking pass
@@ -264,7 +268,7 @@ impl Vmmc {
         while !worklist.is_empty() {
             // A new particle tries to link to its neighbors
             let id = worklist.pop_front().unwrap();
-            let particle = &self.particles[id];
+            let particle = self.particle(id);
             seen.insert(id);
 
             let final_p = self.calculate_motion(particle, mov, seed, MoveDir::Forward);
@@ -279,7 +283,7 @@ impl Vmmc {
                     .determine_interactions(&self.simbox, &self.particles, particle);
 
             for &neighbor_id in interactions.iter() {
-                let neighbor = &self.particles[neighbor_id];
+                let neighbor = self.particle(neighbor_id);
 
                 let (link_weight, reverse_link_weight) =
                     self.compute_link_weights(particle, neighbor, &final_p, &reverse_p);
@@ -356,13 +360,13 @@ impl Vmmc {
         (link_weight, reverse_link_weight)
     }
 
-    fn choose_seed(&self, rng: &mut ThreadRng) -> ParticleId {
-        rng.gen_range(0..self.particles.len())
+    fn choose_seed(&self, rng: &mut SmallRng) -> ParticleId {
+        rng.gen_range(0..self.particles.len() as u16)
     }
 
     fn commit_moves(&mut self, vmoves: &VirtualMoves) {
         for (p_id, vp) in vmoves.inner.iter() {
-            let p = &mut self.particles[*p_id];
+            let p = &mut self.particles[*p_id as usize];
             self.simbox.move_particle_tenancy(*p_id, p.pos(), vp.pos());
             p.update_pos(vp.pos());
             p.update_or(vp.or());
@@ -371,7 +375,7 @@ impl Vmmc {
 
     fn revert_moves(&mut self, vmoves: &VirtualMoves) {
         for (p_id, vp) in vmoves.inner.iter() {
-            let p = &mut self.particles[*p_id];
+            let p = &mut self.particles[*p_id as usize];
             self.simbox
                 .move_particle_tenancy(*p_id, p.pos(), vp.orig_pos());
             p.update_pos(vp.orig_pos());
@@ -381,7 +385,7 @@ impl Vmmc {
 
     fn attempt_commit(
         &mut self,
-        rng: &mut ThreadRng,
+        rng: &mut SmallRng,
         mov: &ProposedMove,
         vmoves: &VirtualMoves,
     ) -> Result<()> {
@@ -400,7 +404,7 @@ impl Vmmc {
 
         // check for overlaps
         for (p_id, _) in vmoves.inner.iter() {
-            let p = &self.particles[*p_id];
+            let p = self.particle(*p_id);
             if self.overlaps(p) {
                 self.revert_moves(vmoves);
                 return Err(anyhow!("Overlapping particle"));
@@ -413,7 +417,7 @@ impl Vmmc {
     // check if a particle overlaps any other particles
     fn overlaps(&self, p: &Particle) -> bool {
         for neighbor_id in self.simbox.get_neighbors(p) {
-            let neighbor = &self.particles[neighbor_id];
+            let neighbor = self.particle(neighbor_id);
             if neighbor == p {
                 continue;
             }
@@ -484,7 +488,7 @@ impl Vmmc {
         true
     }
 
-    fn step(&mut self, rng: &mut ThreadRng, stats: &mut RunStats) -> Result<()> {
+    fn step(&mut self, rng: &mut SmallRng, stats: &mut RunStats) -> Result<()> {
         debug_assert!(self.well_formed());
         stats.record_attempt();
         let mov = self.choose_random_move(rng);
@@ -499,12 +503,11 @@ impl Vmmc {
         Ok(())
     }
 
-    pub fn step_n(&mut self, n: usize) {
-        let mut rng = rand::thread_rng();
+    pub fn step_n(&mut self, n: usize, rng: &mut SmallRng) {
         let mut run_stats = RunStats::new(self.particles.len());
         for idx in 0..n {
             log::info!("Successful moves: {:?}/{:?}", run_stats.num_accepts(), idx);
-            let _ = self.step(&mut rng, &mut run_stats);
+            let _ = self.step(rng, &mut run_stats);
         }
         // println!("{:?}", run_stats);
     }
